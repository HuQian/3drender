#include <cassert>
#include <cstdio>
#include <iostream>
#include <memory>
#include <string>
#include <Eigen/Dense>

// this hpp give a define of yyparse that generated by bison
#include "parser.tab.hpp"

#include "ast.hpp"

using namespace std;

// defined in code that generated by flex
extern FILE *yyin;



bool
trans_obj_index_to_arr(int idx, size_t* i, int v_list_size) {
  if (idx >= 1 && idx <= v_list_size) {
    *i = idx - 1;
    return true;
  } else if (-idx >= 1 && -idx <= v_list_size) {
    *i = idx + v_list_size;
    return true;
  }

  return false;
}

ModelData*
loadModel(const char* mode_file) {
  yyin = fopen(mode_file, "r");
  assert(yyin);

  ModelData* model_data = new ModelData();

  auto ret = yyparse(model_data);
  printf ("[%d]\n", ret);
  assert(!ret);

  for (auto& point : model_data->point_list) {
    size_t i = 0;

    if (!trans_obj_index_to_arr(point.index_pos, &i, model_data->v_list.size()))
      goto out;

    auto& vertex = model_data->v_list[i];

    point.vertex[0] = vertex.x;
    point.vertex[1] = vertex.y;
    point.vertex[2] = vertex.z;
    point.vertex[3] = 1;
  }

  for (auto& line : model_data->line_list) {
    for (auto index : line.index_pos_list) {
      size_t i = 0;

      if (!trans_obj_index_to_arr(index, &i, model_data->v_list.size()))
        goto out;

      auto& vertex = model_data->v_list[i];

      line.vertex_pos_list.push_back(Eigen::Vector4d(vertex.x, vertex.y, vertex.z, 1));
    }
  }

  for (auto& face : model_data->face_list) {
    for (auto index : face.index_pos_list) {
      size_t i = 0;

      if (!trans_obj_index_to_arr(index, &i, model_data->v_list.size()))
        goto out;

      auto& vertex = model_data->v_list[i];
      face.vertex_pos_list.push_back(Eigen::Vector4d(vertex.x, vertex.y, vertex.z, 1));
    }

    for (auto index : face.index_texture_list) {
      size_t i = 0;

      if (!trans_obj_index_to_arr(index, &i, model_data->vt_list.size()))
        goto out;

      auto& texture = model_data->vt_list[i];
      face.vertex_texture_list.push_back(Eigen::Vector3d(texture.u, texture.v, 0));
    }

    for (auto index : face.index_normal_list) {
      size_t i = 0;

      if (!trans_obj_index_to_arr(index, &i, model_data->vn_list.size()))
        goto out;

      auto& normal = model_data->vn_list[i];
      face.vertex_normal_list.push_back(Eigen::Vector4d(normal.dx, normal.dy, normal.dz, 0));
    }
  }

  return model_data;

out:
  printf ("Error: fail determine\n");
  delete model_data;
  return NULL;
}


/*
e : eye postion
g : look at direction
t : up direction
*/
Eigen::MatrixXd
constructMview(double Xe, double Ye, double Ze,
              double Xg, double Yg, double Zg,
              double Xt, double Yt, double Zt) {
  Eigen::MatrixXd Tview = Eigen::MatrixXd::Identity(4,4);
  Tview(0,3) = -Xe;
  Tview(1,3) = -Ye;
  Tview(2,3) = -Ze;

  Eigen::Vector3d VecG = Eigen::Vector3d(Xg, Yg, Zg).normalized();
  Eigen::Vector3d VecT = Eigen::Vector3d(Xt, Yt, Zt).normalized();
  Eigen::Vector3d VecM = VecG.cross(VecT);

  Eigen::MatrixXd Rview = Eigen::MatrixXd::Identity(4,4);
  Rview(0,0) = VecM(0);
  Rview(1,0) = VecM(1);
  Rview(2,0) = VecM(2);

  Rview(0,1) = VecT(0);
  Rview(1,1) = VecT(1);
  Rview(2,1) = VecT(2);

  Rview(0,2) = -VecG(0);
  Rview(1,2) = -VecG(1);
  Rview(2,2) = -VecG(2);

  Rview.transposeInPlace();

  return Rview * Tview;
}

/*
n : near 
f : far
l : left
r : right
b : bottom
t : top
*/
Eigen::MatrixXd
constructMproject(double n, double f, double l, double r, double b, double t) {
  Eigen::MatrixXd Mpress= Eigen::MatrixXd::Zero(4,4);
  Mpress(0,0) = n ;
  Mpress(1,1) = n;
  Mpress(2,2) = n+f;
  Mpress(2,3) = -n*f;
  Mpress(3,2) = 1;
  std::cout << "Mpress \n" << Mpress << std::endl;

  Eigen::MatrixXd MorthoTrans = Eigen::MatrixXd::Identity(4,4);
  MorthoTrans(0,3) = -(r + l) / 2 ;
  MorthoTrans(1,3) = -(t + b) / 2;
  MorthoTrans(2,3) = -(f + n) / 2;
  std::cout << "MorthoTrans \n" << MorthoTrans << std::endl;

  Eigen::MatrixXd MorthoScale = Eigen::MatrixXd::Identity(4,4);
  MorthoScale(0,0) = 2 / (r - l);
  MorthoScale(1,1) = 2 / (t - b);
  MorthoScale(2,2) = 2 / (n - f);
  std::cout << "MorthoScale \n" << MorthoScale << std::endl;

#if 1
  return MorthoScale * MorthoTrans * Mpress;
#else
  return MorthoScale * MorthoTrans;
#endif
}

int main(int argc, const char *argv[]) {

  assert(argc == 2);
  auto input = argv[1];

  ModelData* model_data = loadModel(input);

  Eigen::MatrixXd m = Eigen::MatrixXd::Identity(4,4);
  m(0,0) = 1;
  m(1,1) = 1;
  m(2,2) = 1;
  model_data->dump();
  model_data->setModel(m);
  model_data->setView(constructMview(0,0,0,
                                    0,0,-1,
                                    0,1,0));
  model_data->setProject(constructMproject(-5,-10,-5,5,-5,5));
  model_data->doTrans(true);
  model_data->doRaster(640, 360);
  model_data->dump();

  delete model_data;

  return 0;
}
