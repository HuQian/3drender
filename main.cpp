#include <cassert>
#include <cstdio>
#include <iostream>
#include <memory>
#include <string>
#include <Eigen/Dense>

// this hpp give a define of yyparse that generated by bison
#include "parser.tab.hpp"

#include "ast.hpp"

using namespace std;

// defined in code that generated by flex
extern FILE *yyin;


ModelData*
loadModel(const char* mode_file) {
  yyin = fopen(mode_file, "r");
  assert(yyin);

  ModelData* model_data = new ModelData();

  auto ret = yyparse(model_data);
  printf ("[%d]\n", ret);
  assert(!ret);

  for (auto& point : model_data->point_list) {
    point.loadV (model_data->v_list);
  }

  for (auto& line : model_data->line_list) {
    line.loadV (model_data->v_list);
  }

  for (auto& face : model_data->face_list) {
    face.loadV(model_data->v_list);
    face.loadVT(model_data->vt_list);
    face.loadVN(model_data->vn_list);
  }

  return model_data;
}


/*
e : eye postion
g : look at direction
t : up direction
*/
Eigen::MatrixXd
constructMview(double Xe, double Ye, double Ze,
              double Xg, double Yg, double Zg,
              double Xt, double Yt, double Zt) {
  Eigen::MatrixXd Tview = Eigen::MatrixXd::Identity(4,4);
  Tview(0,3) = -Xe;
  Tview(1,3) = -Ye;
  Tview(2,3) = -Ze;

  Eigen::Vector3d VecG = Eigen::Vector3d(Xg, Yg, Zg).normalized();
  Eigen::Vector3d VecT = Eigen::Vector3d(Xt, Yt, Zt).normalized();
  Eigen::Vector3d VecM = VecG.cross(VecT);

  Eigen::MatrixXd Rview = Eigen::MatrixXd::Identity(4,4);
  Rview(0,0) = VecM(0);
  Rview(1,0) = VecM(1);
  Rview(2,0) = VecM(2);

  Rview(0,1) = VecT(0);
  Rview(1,1) = VecT(1);
  Rview(2,1) = VecT(2);

  Rview(0,2) = -VecG(0);
  Rview(1,2) = -VecG(1);
  Rview(2,2) = -VecG(2);

  Rview.transposeInPlace();

  return Rview * Tview;
}

/*
n : near 
f : far
l : left
r : right
b : bottom
t : top
*/
Eigen::MatrixXd
constructMproject(double n, double f, double l, double r, double b, double t) {
  Eigen::MatrixXd Mpress= Eigen::MatrixXd::Zero(4,4);
  Mpress(0,0) = n ;
  Mpress(1,1) = n;
  Mpress(2,2) = n+f;
  Mpress(2,3) = -n*f;
  Mpress(3,2) = 1;
  std::cout << "Mpress \n" << Mpress << std::endl;

  Eigen::MatrixXd MorthoTrans = Eigen::MatrixXd::Identity(4,4);
  MorthoTrans(0,3) = -(r + l) / 2 ;
  MorthoTrans(1,3) = -(t + b) / 2;
  MorthoTrans(2,3) = -(f + n) / 2;
  std::cout << "MorthoTrans \n" << MorthoTrans << std::endl;

  Eigen::MatrixXd MorthoScale = Eigen::MatrixXd::Identity(4,4);
  MorthoScale(0,0) = 2 / (r - l);
  MorthoScale(1,1) = 2 / (t - b);
  MorthoScale(2,2) = 2 / (n - f);
  std::cout << "MorthoScale \n" << MorthoScale << std::endl;

#if 1
  return MorthoScale * MorthoTrans * Mpress;
#else
  return MorthoScale * MorthoTrans;
#endif
}

int main(int argc, const char *argv[]) {

  assert(argc == 2);
  auto input = argv[1];

  ModelData* model_data = loadModel(input);

  Eigen::MatrixXd m = Eigen::MatrixXd::Identity(4,4);
  m(0,0) = 1;
  m(1,1) = 1;
  m(2,2) = 1;
  model_data->dump();
  model_data->setModel(m);
  model_data->setView(constructMview(0,0,0,
                                    0,0,-1,
                                    0,1,0));
  model_data->setProject(constructMproject(-5,-10,-5,5,-5,5));
  model_data->doTrans();
  model_data->doRaster(640, 360);
  model_data->dump();

  delete model_data;

  return 0;
}
